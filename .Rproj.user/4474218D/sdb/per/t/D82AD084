{
    "contents" : "library(httpuv)\nlibrary(Rook)\nlibrary(ggplot2)\nlibrary(gg2v)\nlibrary(RJSONIO)\nlibrary(whisker)\n\n# Convert a ggplot2 plot object to a JS vega spec with related gigvis calls\nplotToScript <- function(id, plotObj) {\n  ps <- plot_spec(plotObj, embed_data=TRUE)\n\n  # Do some monkeypatching of the generated vega plotspec. The monkeypatching\n  # is very crude, assumes only 1 data item and 1 mark.\n\n  # Add a data source that will represent the brush\n  ps$data[[2]] <- list(\n    name = \"brush\",\n    values = list(\n      list(\n        x = 0, y = 0, width = 0, height = 0\n      )\n    )\n  )\n\n  # Change the mark specification to make it look a little nicer\n  ps$marks[[1]]$properties$update$size <- list(value = 20)\n  ps$marks[[1]]$properties$update$stroke <- list(value = \"transparent\")\n  ps$marks[[1]]$properties$update$opacity <- list(value = 0.5)\n\n  # Add a mark property set for selected (linked) data points\n  ps$marks[[1]]$properties$selected <- list(\n    fill=list(\n      value=\"#00CC00\"\n    )\n  )\n\n  # Add a mark for the brushing rectangle\n  ps$marks[[2]] <- list(\n    type = \"rect\",\n    from = list(data = \"brush\"),\n    properties = list(\n      update = list(\n        x = list(field = \"data.x\"),\n        y = list(field = \"data.y\"),\n        width = list(field = \"data.width\"),\n        height = list(field = \"data.height\"),\n        stroke = list(value = \"#CCC\"),\n        fill = list(value = \"transparent\"),\n        opacity = list(value = 1.0)\n      )\n    )\n  )\n\n  json <- toJSON(ps)\n  whisker.render(\"<script>\nvg.parse.spec({{{json}}}, function(chart) {\n  gigvis.addChart('{{id}}', chart({el: '#{{id}}'}).update());\n})\n</script>\")\n}\n\n# Custom content for the <head> of the webpage\nheadFunc <- function() {\n  diamonds <- diamonds[sample(nrow(diamonds), 500),]\n  paste(\n    sep = '\\n',\n    plotToScript('vis', qplot(Response, Freq, data=csat[csat$citystate==\"St. Paul, MN\",]))\n  )\n}\n\n# Custom content for the <body> of the webpage\nbodyFunc <- function() {\n  paste('<div class=\"plots\">',\n        '<div id=\"vis\"></div>',\n        '<div id=\"vis2\"></div>',\n        '<div id=\"vis3\"></div>',\n        '<div id=\"vis4\"></div>',\n        '</div>')\n}\n\n\n\nrootDir <- system.file('', package='gigvis')\n\n# Serves up files in the www directory\nlibServer <- Rook::File$new(file.path(rootDir, 'www'))\n\ntemplate <- paste(readLines(file.path(rootDir, 'index.html')), collapse='\\n')\n\n# This is our rook/httpuv app\napp <- list(\n  call = function(req) {\n\n    # Try using static resources in www to fulfill the request\n    resp <- suppressWarnings(libServer$call(req))\n    if (resp$status == 200)\n      return(resp)\n\n    # Nothing static found; handle it dynamically if possible\n\n    switch (\n      req$PATH_INFO,\n      '/' = {\n        cat(\"Rendering page...\\n\")\n        print(system.time({\n          response <- list(status = 200L,\n                           headers = list('Content-Type' = 'text/html'),\n                           body = whisker.render(template,\n                                                 list(head = headFunc(),\n                                                      body = bodyFunc())))\n        }))\n        response\n      },\n      list(status = 404L,\n           headers = list('Content-Type' = 'text/plain'),\n           body = 'Not found')\n    )\n  },\n  onWSOpen = function(ws) {\n    ws$onMessage(function(binary, message) {\n      if (binary) {\n        warning(\"Binary websocket message was not expected\")\n        ws$close()\n        return()\n      }\n\n      msg <- fromJSON(message)\n      str(msg)\n    })\n    ws$onClose(function() {\n\n    })\n  }\n)\n\nrunServer('0.0.0.0', 8101, app)\n",
    "created" : 1375485571663.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "118|27|132|2|\n",
    "hash" : "961303830",
    "id" : "D82AD084",
    "lastKnownWriteTime" : 1375487941,
    "path" : "~/gigvis/demo/linkedbrushing.r",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}